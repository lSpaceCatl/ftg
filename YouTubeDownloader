import os

from telethon.tl.types import DocumentAttributeAudio
from youtube_dl import YoutubeDL
from youtube_dl.utils import (DownloadError, ContentTooShortError,
                              ExtractorError, GeoRestrictedError,
                              MaxDownloadsReached, PostProcessingError,
                              UnavailableVideoError, XAttrMetadataError)

from .. import loader, utils


@loader.tds
class YouTubeDownloadeMod(loader.Module):
 """YoutubeDownloade Module"""
 strings = {
  "name": "Youtube-Dl",
  "preparing": "<b>[YouTube-Dl]</b> Поиск",
  "downloading": "<b>[YouTube-Dl]</b> Загрузка",
  "working": "<b>[YouTube-Dl]</b> Работа",
  "exporting": "<b>[YouTube-Dl]</b> Экспорт.",
  "reply": "<b>[YouTube-Dl]</b> Нет ссылки",
  "noargs": "<b>[YouTube-Dl]</b> Нет аргумента",
  "content_too_short": "<b>[YouTube-Dl]</b> Скачиваемый контент слишком короткий(как твой писюн хехе)!",
  "geoban": "<b>[YouTube-Dl]</b> Бан по гео в ютабе
  "maxdlserr": "<b>[YouTube-Dl]</b> Достигнут лимит загрузок для подписчиков \"АХАХАХАХАХАХАХАХА ЛОХ\"",
  "pperr": "<b>[YouTube-Dl]</b> Ошибка пост обработки",
  "noformat": "<b>[YouTube-Dl]</b> Не тот формат медиа",
  "xameerr": "<b>[YouTube-Dl]</b> {0.code}: {0.msg}\n{0.reason}",
  "exporterr": "<b>[YouTube-Dl]</b> Ошибка экспорта видео",
  "err": "<b>[YouTube-Dl]</b> {}",
  "err2": "<b>[YouTube-Dl]</b> {}: {}"
 }

 async def ripvcmd(self, m):
  """.ripv <link / reply_to_link> - скачать видео"""
  await riper(self, m, "video")

 async def ripacmd(self, m):
  """.ripa <link / reply_to_link> - скачать аудио"""
  await riper(self, m, "audio")


async def riper(self, m, type):
 reply = await m.get_reply_message()
 args = utils.get_args_raw(m)
 url = args or reply.raw_text
 if not url:
  return await utils.answer(m, self.strings("noargs", m))
 m = await utils.answer(m, self.strings("preparing", m))
 if type == "audio":
  opts = {
   'format':
    'bestaudio',
   'addmetadata':
    True,
   'key':
    'FFmpegMetadata',
   'writethumbnail':
    True,
   'prefer_ffmpeg':
    True,
   'geo_bypass':
    True,
   'nocheckcertificate':
    True,
   'postprocessors': [{
    'key': 'FFmpegExtractAudio',
    'preferredcodec': 'mp3',
    'preferredquality': '320',
   }],
   'outtmpl':
    '%(id)s.mp3',
   'quiet':
    True,
   'logtostderr':
    False
  }
  video = False
  song = True
 elif type == "video":
  opts = {
   'format':
    'best',
   'addmetadata':
    True,
   'key':
    'FFmpegMetadata',
   'prefer_ffmpeg':
    True,
   'geo_bypass':
    True,
   'nocheckcertificate':
    True,
   'postprocessors': [{
    'key': 'FFmpegVideoConvertor',
    'preferedformat': 'mp4'
   }],
   'outtmpl':
    '%(id)s.mp4',
   'logtostderr':
    False,
   'quiet':
    True
  }
  song = False
  video = True
 try:
  await utils.answer(m, self.strings("downloading", m))
  with YoutubeDL(opts) as rip:
   rip_data = rip.extract_info(url)
 except DownloadError as DE:
  return await utils.answer(m, self.strings("err", m).format(str(DE)))
 except ContentTooShortError:
  return await utils.answer(m, self.strings("content_too_short", m))
 except GeoRestrictedError:
  return await utils.answer(m, self.strings("geoban", m))
 except MaxDownloadsReached:
  return await utils.answer(m, self.strings("maxdlserr", m))
 except PostProcessingError:
  return await utils.answer(m, self.strings("pperr", m))
 except UnavailableVideoError:
  return await utils.answer(m, self.strings("noformat", m))
 except XAttrMetadataError as XAME:
  return await utils.answer(m, self.strings("xameerr", m).format(XAME))
 except ExtractorError:
  return await utils.answer(m, self.strings("exporterr", m))
 except Exception as e:
  return await utils.answer(m, self.strings("err2", m).format(str(type(e)), str(e)))
 if song:
  u = rip_data['uploader'] if 'uploader' in rip_data else 'Northing'
  await utils.answer(m,
                     open(f"{rip_data['id']}.mp3", "rb"),
                     supports_streaming=True,
                     reply_to=reply.id if reply else None,
                     attributes=[
                      DocumentAttributeAudio(duration=int(rip_data['duration']),
                                             title=str(rip_data['title']),
                                             performer=u)
                     ]
                     )
  os.remove(f"{rip_data['id']}.mp3")
 elif video:
  await utils.answer(m,
                     open(f"{rip_data['id']}.mp4", "rb"),
                     reply_to=reply.id if reply else None,
                     supports_streaming=True,
                     caption=rip_data['title']
                     )
  os.remove(f"{rip_data['id']}.mp4")
